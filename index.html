<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Logan’s Geometrie Crash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&family=Inter:wght@400;900&display=swap');
        
        body { 
            margin: 0; padding: 0; overflow: hidden; 
            background: #020617; touch-action: none; 
            font-family: 'Inter', sans-serif; color: white;
        }
        canvas { display: block; }
        .font-game { font-family: 'Orbitron', sans-serif; }
        .overlay {
            position: absolute; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: rgba(2, 6, 23, 0.95); z-index: 100;
        }
        .btn-diff {
            width: 260px; padding: 20px; margin: 8px;
            border-radius: 12px; font-weight: 900; font-size: 1.2rem;
            text-transform: uppercase; letter-spacing: 2px;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: none; box-shadow: 0 6px 0 rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .btn-diff:active { transform: translateY(4px); box-shadow: none; }
        .btn-leicht { background: #10b981; }
        .btn-mittel { background: #f59e0b; }
        .btn-schwer { background: #ef4444; }
        .btn-retry { background: #38bdf8; color: #020617; }
        .btn-menu { background: #ffffff; color: #020617; }

        #ui-top {
            position: absolute; top: 20px; left: 20px; right: 20px;
            display: flex; justify-content: space-between;
            pointer-events: none; z-index: 50;
        }
        .score-box {
            background: rgba(30, 41, 59, 0.6); padding: 8px 16px;
            border-radius: 8px; border: 1px solid rgba(56, 189, 248, 0.2);
            backdrop-filter: blur(8px);
        }
    </style>
</head>
<body>

    <div id="startMenu" class="overlay">
        <h1 class="text-3xl md:text-5xl font-game font-black mb-2 text-center uppercase tracking-tighter">
            LOGAN'S <span class="text-sky-500">GEOMETRIE</span> CRASH
        </h1>
        <p class="text-slate-500 mb-10 text-xs tracking-[0.3em] uppercase">Wähle deine Schwierigkeit</p>
        <button class="btn-diff btn-leicht font-game" onclick="window.startGame('leicht')">Leicht</button>
        <button class="btn-diff btn-mittel font-game" onclick="window.startGame('mittel')">Mittel</button>
        <button class="btn-diff btn-schwer font-game" onclick="window.startGame('schwer')">Schwer</button>
    </div>

    <div id="gameOver" class="overlay" style="display:none;">
        <h2 class="text-5xl font-game font-black text-red-500 mb-2 italic text-center uppercase">System Crash</h2>
        <div class="text-slate-400 text-xs tracking-widest uppercase mb-1">Endergebnis</div>
        <div class="text-7xl font-game font-black text-white mb-10" id="finalScore">0</div>
        
        <div class="flex flex-col space-y-2">
            <button class="btn-diff btn-retry font-game" onclick="window.startGame(window.getCurrentDiff())">Nochmal</button>
            <button class="btn-diff btn-menu font-game" onclick="window.resetToMenu()">Menü</button>
        </div>
    </div>

    <div id="ui-top">
        <div class="score-box">
            <div class="text-[10px] text-sky-400 uppercase font-bold">Punkte</div>
            <div class="text-2xl font-black font-game" id="liveScore">0</div>
        </div>
        <div class="score-box text-right">
            <div class="text-[10px] text-slate-400 uppercase font-bold">Modus</div>
            <div class="text-sm font-bold font-game" id="modeDisplay">-</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
(function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startMenu = document.getElementById('startMenu');
    const gameOverMenu = document.getElementById('gameOver');
    const liveScoreEl = document.getElementById('liveScore');
    const finalScoreEl = document.getElementById('finalScore');
    const modeDisplay = document.getElementById('modeDisplay');

    let gameW, gameH, gameActive = false, score = 0, frameCount = 0, currentDifficulty = 'leicht';
    const inputState = { ArrowLeft: false, ArrowRight: false, ArrowUp: false };
    
    let touchStartY = 0;
    let swipeDone = false;

    const gameConfig = {
        leicht: { jump: -16.5, rate: 55, sideRate: 170, color: '#10b981' },
        mittel: { jump: -13.8, rate: 40, sideRate: 120, color: '#f59e0b' },
        schwer: { jump: -11.9, rate: 24, sideRate: 85, color: '#ef4444' }
    };

    const player = {
        x: 0, y: 0, size: 42, vy: 0, grav: 0.8, jumpPower: -16, 
        groundPos: 0, speed: 10, isJumping: false, trail: []
    };

    let enemies = [], sideEnemies = [], fxParticles = [];

    function resize() {
        gameW = window.innerWidth;
        gameH = window.innerHeight;
        canvas.width = gameW; 
        canvas.height = gameH;
        player.groundPos = gameH - 140;
        if(!gameActive) { 
            player.x = gameW/2 - player.size/2; 
            player.y = player.groundPos; 
        }
    }
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('keydown', e => { 
        if(e.code === 'ArrowLeft') inputState.ArrowLeft = true;
        if(e.code === 'ArrowRight') inputState.ArrowRight = true;
        if(e.code === 'Space' || e.code === 'ArrowUp') inputState.ArrowUp = true;
        if(["Space", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.code)) e.preventDefault();
    });
    window.addEventListener('keyup', e => {
        if(e.code === 'ArrowLeft') inputState.ArrowLeft = false;
        if(e.code === 'ArrowRight') inputState.ArrowRight = false;
        if(e.code === 'Space' || e.code === 'ArrowUp') inputState.ArrowUp = false;
    });

    canvas.addEventListener('touchstart', e => {
        if(!gameActive) return;
        const t = e.touches[0];
        touchStartY = t.clientY;
        swipeDone = false;
        handleMovement(t.clientX);
        e.preventDefault();
    }, {passive:false});

    canvas.addEventListener('touchmove', e => {
        if(!gameActive) return;
        const t = e.touches[0];
        if(!swipeDone && touchStartY - t.clientY > 45) {
            inputState.ArrowUp = true;
            swipeDone = true;
            setTimeout(() => inputState.ArrowUp = false, 100);
        }
        handleMovement(t.clientX);
        e.preventDefault();
    }, {passive:false});

    canvas.addEventListener('touchend', () => { 
        inputState.ArrowLeft = false; 
        inputState.ArrowRight = false; 
    });

    function handleMovement(clientX) {
        if(clientX < gameW/2) { inputState.ArrowLeft = true; inputState.ArrowRight = false; }
        else { inputState.ArrowRight = true; inputState.ArrowLeft = false; }
    }

    window.getCurrentDiff = function() { return currentDifficulty; };

    window.startGame = function(diff) {
        currentDifficulty = diff;
        const c = gameConfig[diff];
        player.jumpPower = c.jump;
        modeDisplay.innerText = diff.toUpperCase();
        modeDisplay.style.color = c.color;
        
        score = 0; frameCount = 0;
        enemies = []; sideEnemies = []; fxParticles = [];
        liveScoreEl.innerText = "0";
        startMenu.style.display = 'none';
        gameOverMenu.style.display = 'none';
        gameActive = true;
        
        player.x = gameW/2 - player.size/2;
        player.y = player.groundPos;
        player.vy = 0; player.isJumping = false;
        player.trail = []; 
    };

    window.resetToMenu = function() {
        gameActive = false;
        gameOverMenu.style.display = 'none';
        startMenu.style.display = 'flex';
    };

    function triggerJump() {
        if(!player.isJumping && gameActive) {
            player.vy = player.jumpPower;
            player.isJumping = true;
            createFX(player.x + player.size/2, player.y + player.size, '#38bdf8', 12);
        }
    }

    function createEnemy() {
        let posX = Math.random() * (gameW - 80);
        let attempts = 0;
        while(attempts < 5) {
            let tooNear = enemies.some(e => Math.abs(e.x - posX) < player.size * 2 && e.y < 150);
            if(!tooNear) break;
            posX = Math.random() * (gameW - 80);
            attempts++;
        }

        const baseSize = 30 + Math.random() * 20;
        let evoLevel = 1;
        if(score > 150) evoLevel = 3; else if(score > 50) evoLevel = 2;

        enemies.push({
            x: posX, y: -100, size: baseSize,
            speed: 4.8 + (score / 35),
            rotation: 0, rotSpeed: (Math.random() - 0.5) * 0.1,
            evolution: evoLevel,
            type: Math.random() > 0.5 ? 'rect' : 'circle'
        });
    }

    function createSideEnemy() {
        const fromLeft = Math.random() > 0.5;
        sideEnemies.push({
            x: fromLeft ? -60 : gameW + 60,
            y: player.groundPos + (player.size - 38),
            size: 38,
            speed: fromLeft ? (5.8 + score/38) : -(5.8 + score/38),
            color: gameConfig[currentDifficulty].color
        });
    }

    function createFX(x, y, col, count) {
        for(let i=0; i<count; i++) {
            fxParticles.push({
                x, y, 
                vx: (Math.random()-0.5)*12, 
                vy: (Math.random()-0.5)*12, 
                life: 1.0, col
            });
        }
    }

    function update() {
        if(!gameActive) return;

        if(inputState.ArrowLeft) player.x -= player.speed;
        if(inputState.ArrowRight) player.x += player.speed;
        if(inputState.ArrowUp) triggerJump();

        player.x = Math.max(0, Math.min(gameW - player.size, player.x));
        player.vy += player.grav;
        player.y += player.vy;
        
        if(player.y >= player.groundPos) {
            player.y = player.groundPos;
            player.vy = 0;
            player.isJumping = false;
        }

        player.trail.push({x: player.x, y: player.y});
        if(player.trail.length > 7) player.trail.shift();

        frameCount++;
        const c = gameConfig[currentDifficulty];
        if(frameCount % c.rate === 0) createEnemy();
        if(frameCount % c.sideRate === 0) createSideEnemy();

        for(let i = enemies.length-1; i >= 0; i--) {
            const e = enemies[i];
            e.y += e.speed; e.rotation += e.rotSpeed;
            if(detectCollision(player, e)) handleCrash();
            if(e.y > gameH + 100) { enemies.splice(i, 1); score++; liveScoreEl.innerText = score; }
        }

        for(let i = sideEnemies.length-1; i >= 0; i--) {
            const e = sideEnemies[i];
            e.x += e.speed;
            if(detectCollision(player, e)) handleCrash();
            if(e.x < -150 || e.x > gameW + 150) sideEnemies.splice(i, 1);
        }

        for(let i = fxParticles.length-1; i >= 0; i--) {
            const p = fxParticles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.03;
            if(p.life <= 0) fxParticles.splice(i, 1);
        }
    }

    function detectCollision(p, o) {
        let collisionBounds = o.size;
        if(o.evolution === 2) collisionBounds *= 1.45;
        if(o.evolution === 3) collisionBounds *= 1.85;
        
        const padding = 6;
        const ox = o.x + o.size/2 - collisionBounds/2;
        const oy = o.y + o.size/2 - collisionBounds/2;

        return p.x + padding < ox + collisionBounds && 
               p.x + p.size - padding > ox &&
               p.y + padding < oy + collisionBounds && 
               p.y + p.size - padding > oy;
    }

    function handleCrash() {
        gameActive = false;
        createFX(player.x + player.size/2, player.y + player.size/2, '#ef4444', 40);
        gameOverMenu.style.display = 'flex';
        finalScoreEl.innerText = score;
    }

    function draw() {
        ctx.clearRect(0, 0, gameW, gameH);
        
        ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(0, player.groundPos + player.size); ctx.lineTo(gameW, player.groundPos + player.size); ctx.stroke();

        fxParticles.forEach(p => {
            ctx.globalAlpha = p.life; ctx.fillStyle = p.col;
            ctx.fillRect(p.x, p.y, 4, 4);
        });
        ctx.globalAlpha = 1;

        enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x + e.size/2, e.y + e.size/2);
            ctx.rotate(e.rotation);
            ctx.fillStyle = '#475569';
            
            if(e.type === 'rect') ctx.fillRect(-e.size/2, -e.size/2, e.size, e.size);
            else { ctx.beginPath(); ctx.arc(0,0, e.size/2, 0, Math.PI*2); ctx.fill(); }

            if(e.evolution >= 2) {
                ctx.fillStyle = '#334155';
                const modSize = e.size * 0.45;
                ctx.fillRect(-e.size/2 - modSize, -modSize/2, modSize, modSize);
                ctx.fillRect(e.size/2, -modSize/2, modSize, modSize);
                ctx.fillRect(-modSize/2, -e.size/2 - modSize, modSize, modSize);
                ctx.fillRect(-modSize/2, e.size/2, modSize, modSize);
            }

            if(e.evolution >= 3) {
                ctx.strokeStyle = '#64748b'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0, 0, e.size * 1.35, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(-e.size*1.65, -3, e.size*3.3, 6);
                ctx.fillRect(-3, -e.size*1.65, 6, e.size*3.3);
            }
            ctx.restore();
        });

        sideEnemies.forEach(e => {
            ctx.fillStyle = e.color;
            ctx.shadowBlur = 15; ctx.shadowColor = e.color;
            ctx.fillRect(e.x, e.y, e.size, e.size);
            ctx.shadowBlur = 0;
        });

        const trailLen = player.trail.length;
        player.trail.forEach((t, i) => {
            const alphaFactor = trailLen > 0 ? (i / trailLen) : 0;
            ctx.globalAlpha = alphaFactor * 0.4;
            ctx.fillStyle = player.color;
            ctx.fillRect(t.x, t.y, player.size, player.size);
        });
        
        ctx.globalAlpha = 1;
        ctx.fillStyle = player.color;
        ctx.shadowBlur = 25; ctx.shadowColor = player.color;
        ctx.fillRect(player.x, player.y, player.size, player.size);
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#020617';
        ctx.fillRect(player.x+10, player.y+12, 6, 6);
        ctx.fillRect(player.x+26, player.y+12, 6, 6);
    }

    function animate() {
        update();
        draw();
        requestAnimationFrame(animate);
    }
    animate();

})();
</script>
</body>
</html>